{
    "contents" : "# Kevin Dang Nguyen\n# Rena Jing\n# ECS 132 - Project 2\n\n#byte <- sample(0:1, 8, replace = T) #to generate random 8 bit vectors\n\n##########################################################################################\n# BASIC STEP\n\n# 1) A-collision\nlappend <- function (lst, ...){\n  lst <- c(lst, list(...))\n  return(lst)\n}\n\nA_average = 0\nA_total = 0\nA_trials = 1000\n\nfor (t in 1:A_trials){\n  \n  array = NULL\n  counter = 1\n  match = 0\n  \n  #insert first element\n  first <- sample(0:1, 8, replace = T)\n  array <- lappend(array, first)\n  \n  repeat{\n\n    byte <- sample(0:1, 8, replace = T)\n    array <- lappend(array, byte)\n    counter = counter + 1\n    \n   for (i in 1:(counter-1)){ \n      \n      if (all(byte == array[[i]])){\n        match = 1\n        break\n      }\n   }\n   if (match == 1){\n     break}\n        \n  }\nA_total = A_total + counter\n}\nA_average = A_total/A_trials\nA_average # about 20\n\n##########################################################################################\n# 2) Assuming 100 trials\nlappend <- function (lst, ...){\n  lst <- c(lst, list(...))\n  return(lst)\n}\n\nA_average = 0\nA_total = 0\nA_trials = 1000\n#trials <- readline(prompt = \"Enter number of trials in S: \")\nS_trials = 1000\nS_total = 0\n\nfor (i in 1:S_trials){\n\nrandom_array = NULL\ncounter = 0\n\nS <- sample(0:1, 8, replace = T) #reference vector for S collision\n\nrepeat\n{\n  byte <- sample(0:1, 8, replace = T)\n  random_array <- lappend(random_array, byte)\n  counter = counter + 1\n  if (all(S == byte)){\n    break;}\n} \nS_total = S_total + counter\n\n}\nS_average = S_total/S_trials\nS_average # about 260\n\n\n##########################################################################################\n# GIVEN A NUMBER OF RANDOMLY GENERATED 8-BIT IVs, FIND THE PROBABILITY FOR BOTH A/S-COLLISION\nA_and_S_collision <- function(N){\n  p = numeric(N)\n  \n  for (n in 1:N){\n    q = 1 - (0:(n-1))/(2^8)\n    p[n] = 1- prod(q)\n  }\n  plot(p, main = 'Probabily of A&S collision', xlab = 'Number of random 8-bit IVs', ylab = 'Probability of collision')\n  p\n}\n  \nA_and_S_collision(50)\n##########################################################################################\n# SCALABILITY\nlappend <- function (lst, ...){\n  lst <- c(lst, list(...))\n  return(lst)\n}\n\nA_average = 0\nA_total = 0\nA_trials = 1000\nS_collision <- function(sizeICV){\n  \ntrials = 100\ntotal = 0\n\nfor (i in 1:trials){\n  \n  random_array = NULL\n  counter = 0\n  \n  S <- sample(0:1, sizeICV, replace = T) #reference vector for S collision\n  \n  repeat\n  {\n    byte <- sample(0:1, sizeICV, replace = T)\n    random_array <- lappend(random_array, byte)\n    counter = counter + 1\n    if (all(S == byte)){\n      break;}\n  } \n  total = total + counter\n  \n}\nS_average = total/trials\nS_average \n}\n\nS_collision(10) # about 1226.03\nS_collision(12) # about 4178.66\nS_collision(14) # about 15750.13\nS_collision(16) # about 63542.38\n\n##########################################################################################\n# ESTIMATION\nS_collision(24) # runs for a very long time\n\n##########################################################################################\n\ncounter = 0\n\n\nS <- sample(0:(2^8), 1, replace = T)\nS\nfor (i in 0:(2^8)){\n  if (i == S){\n    break\n  }\n  counter = counter + 1  \n}\ncounter\n##########################################################################################\n# Practical Scenario\ntime_8 = 416000000/(2^8) # 1625000\ntime_8\ntime_16 = 416000000/(2^16) # 6347.656\ntime_16\n\n##########################################################################################\n# 4 DISCUSSION\n\n1. A possible strategy is alternating between ascending and descending counters, \nwhich is more efficient than ascending, A-collision, and S-collision. It is \nmore efficient than S-collisions and ascending collisions because both require\ntraversal of the elements from the beginning of the array, whilst ascending\nand descending counters can simply estimate where the IV value is centered\naround and gauge based on the estimate the byte it is closer to, thus decreasing\nthe range that we have to search in. \n\n\n\n2. A-collision is the most efficient strategy because it has the shortest run\ntimes out of ascending order and S-collision according to the simulations. Also,\nsince you are increasing the number of reference points, there is a higher \nprobability of a collision as opposed to having just one reference point in\nan S-collision. The A-collision strategy is more efficient because at the worst \ncase, say if the byte was the larger than all the values in the array for the ascending order strategy,  the ascending-order strategy requires a traversal through the entire\narray, which would be inefficient as opposed to having randomly generated \nbytes.",
    "created" : 1416601595388.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1867804417",
    "id" : "10213B80",
    "lastKnownWriteTime" : 1416601650,
    "path" : "C:/Users/Kevin Dang Nguyen/Desktop/ECS132 - Project2/Project2.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}